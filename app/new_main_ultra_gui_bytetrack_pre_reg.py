import argparse
import sys
from pathlib import Path

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú ÏÑ§Ï†ï
PROJECT_ROOT = Path(__file__).resolve().parent.parent
EXTRA_PATHS = [
    str(PROJECT_ROOT),                      # Î£®Ìä∏ ÏûêÏ≤¥ (app, frontend Îì± import Í∞ÄÎä•)
    str(PROJECT_ROOT / "deep-person-reid-master"),  # ÌïÑÏöîÌïú Í≤ΩÏö∞Îßå
    str(PROJECT_ROOT / "app" / "models" / "mapping"),   # point_transformer Í≤ΩÎ°ú ÏàòÏ†ï
]

for p in EXTRA_PATHS:
    if p not in sys.path:
        sys.path.insert(0, p)

# np.float Ìò∏ÌôòÏÑ± Î¨∏Ï†ú Ìï¥Í≤∞
import numpy as np
if not hasattr(np, 'float'):
    np.float = float

import cv2
import time
import threading
from config import settings
from integrated_tracking_system_ultra import IntegratedTrackingSystemUltra


class GUIVideoProcessor:
    """GUI ÌôîÎ©¥ÏùÑ ÌëúÏãúÌïòÎäî ÎπÑÎîîÏò§ Ï≤òÎ¶¨ ÌÅ¥ÎûòÏä§ (ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©)"""
    
    def __init__(self, tracking_system):
        self.tracking_system = tracking_system
        self.video_paths = tracking_system.video_paths
        self.stop_event = threading.Event()
        self.detectors = {}
        
        # GUI ÏÑ§Ï†ï
        self.window_names = []
        self.video_windows = {}
        
        # ÏÑ±Îä• Ï∏°Ï†ï
        self.fps_counters = {}
        self.frame_times = {}
        
    def create_detector_for_thread(self, camera_id):
        """Ïä§Î†àÎìúÎ≥Ñ ÎèÖÎ¶ΩÏ†ÅÏù∏ detector ÏÉùÏÑ±"""
        if camera_id not in self.detectors:
            self.detectors[camera_id] = self.tracking_system.create_detector_for_thread()
        return self.detectors[camera_id]
    
    def process_video_thread(self, video_path, camera_id):
        """ÎπÑÎîîÏò§ Ï≤òÎ¶¨ Ïä§Î†àÎìú (GUI ÌëúÏãúÏö©) - ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©"""
        try:
            detector = self.create_detector_for_thread(camera_id)
            
            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                print(f"‚ùå Could not open video: {video_path}")
                return
            
            # ÏúàÎèÑÏö∞ ÏÉùÏÑ±
            window_name = f"Camera {camera_id} - {Path(video_path).name} (ByteTrack + Pre-Reg)"
            cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
            cv2.resizeWindow(window_name, 1920, 1080)
            self.window_names.append(window_name)
            
            frame_id = 0
            start_time = time.time()
            
            print(f"üé• Started processing Camera {camera_id}: {video_path} (ByteTrack + Pre-Registration)")
            
            while cap.isOpened() and not self.stop_event.is_set():
                ret, frame = cap.read()
                if not ret:
                    print(f"üìπ Camera {camera_id} video ended")
                    break
                
                frame_id += 1
                
                # ÌîÑÎ†àÏûÑ Ïä§ÌÇµ (ÏÑ±Îä• Ìñ•ÏÉÅ)
                if frame_id % 2 != 0:  # 2ÌîÑÎ†àÏûÑÎßàÎã§ Ï≤òÎ¶¨
                    continue
                
                # Ï≤òÎ¶¨ ÏãúÍ∞Ñ Ï∏°Ï†ï
                frame_start_time = time.time()
                
                # ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©
                track_list = detector.detect_and_track(frame, frame_id)
                
                # Í≤∞Í≥ºÎ•º Í∏∞Ï°¥ ÌòïÏãùÏóê ÎßûÍ≤å Î≥ÄÌôò
                detections = []
                violations = []  # PPE Í≤ÄÏÇ¨Îäî ÏùºÎã® ÎπÑÌôúÏÑ±Ìôî
                
                for track in track_list:
                    track_id = track["track_id"]
                    bbox = track["bbox"]
                    confidence = track.get("confidence", 0.0)
                    
                    x1, y1, x2, y2 = map(int, bbox)
                    
                    # Pre-Registration MatcherÎßå ÏÇ¨Ïö©ÌïòÏó¨ Global ID Í≤∞Ï†ï
                    global_id = self.match_with_pre_registration_only(frame, bbox, camera_id, frame_id, track_id)
                    
                    # Î∞îÏö¥Îî© Î∞ïÏä§ Í∑∏Î¶¨Í∏∞
                    color = (0, 255, 0) if global_id == track_id else (0, 255, 255)  # Îß§Ïπ≠ÎêòÎ©¥ ÎÖ∏ÎûÄÏÉâ
                    cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                    cv2.putText(frame, f'ID:{global_id} ({confidence:.2f})', 
                               (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
                    
                    # detection Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                    detection_data = {
                        "cameraID": camera_id,
                        "workerID": global_id,  # Pre-Registration Í≤∞Í≥º ÏÇ¨Ïö©
                        "position_X": (x1 + x2) / 2,  # Í∞ÑÎã®Ìïú Ï§ëÏã¨Ï†ê Í≥ÑÏÇ∞
                        "position_Y": (y1 + y2) / 2,
                        "frame_id": frame_id
                    }
                    detections.append(detection_data)
                
                processed_frame = frame  # ÏõêÎ≥∏ ÌîÑÎ†àÏûÑ ÏÇ¨Ïö©
                
                # FPS Í≥ÑÏÇ∞
                frame_time = time.time() - frame_start_time
                if camera_id not in self.fps_counters:
                    self.fps_counters[camera_id] = []
                self.fps_counters[camera_id].append(frame_time)
                
                # ÏµúÍ∑º 30ÌîÑÎ†àÏûÑÏùò ÌèâÍ∑† FPS Í≥ÑÏÇ∞
                if len(self.fps_counters[camera_id]) > 30:
                    self.fps_counters[camera_id] = self.fps_counters[camera_id][-30:]
                
                avg_fps = 1.0 / (sum(self.fps_counters[camera_id]) / len(self.fps_counters[camera_id])) if self.fps_counters[camera_id] else 0
                
                # GUI Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                self.add_gui_info(processed_frame, camera_id, frame_id, len(detections), avg_fps, violations)
                
                # Ï∫êÏãú ÌÜµÍ≥Ñ Ï∂úÎ†• (30ÌîÑÎ†àÏûÑÎßàÎã§)
                if frame_id % 30 == 0:
                    self.tracking_system.matching_cache_manager.print_cache_stats()
                
                # ÌôîÎ©¥Ïóê ÌëúÏãú
                cv2.imshow(window_name, processed_frame)
                
                # ÌÇ§ ÏûÖÎ†• Ï≤òÎ¶¨
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    self.stop_event.set()
                    break
                elif key == ord('s'):  # Ïä§ÌÅ¨Î¶∞ÏÉ∑ Ï†ÄÏû•
                    screenshot_path = f"screenshot_camera_{camera_id}_{frame_id}_bytetrack_pre_reg.jpg"
                    cv2.imwrite(screenshot_path, processed_frame)
                    print(f"üì∏ Screenshot saved: {screenshot_path}")
            
            cap.release()
            print(f"‚úÖ Camera {camera_id} processing completed (ByteTrack + Pre-Registration)")
            
        except Exception as e:
            print(f"‚ùå Error in camera {camera_id} processing: {e}")
            import traceback
            traceback.print_exc()
    
    def match_with_pre_registration_only(self, frame, bbox, camera_id, frame_id, local_id):
        """
        Pre-Registration MatcherÎßå ÏÇ¨Ïö©ÌïòÏó¨ Global ID Í≤∞Ï†ï (Ï∫êÏãú Í∏∞Î∞ò)
        Í∞ùÏ≤¥Í∞Ä Ï≤òÏùå ÌÉêÏßÄÎê† ÎïåÎßå ÏÇ¨Ï†Ñ Îì±Î°ù Îß§Ïπ≠ÏùÑ ÏàòÌñâÌïòÍ≥†, Ïù¥ÌõÑÏóêÎäî Ï∫êÏãúÎêú Í≤∞Í≥º ÏÇ¨Ïö©
        """
        # 1. Ï∫êÏãú ÌôïÏù∏ (Ïù¥ÎØ∏ Îß§Ïπ≠Îêú Í∞ùÏ≤¥)
        cached_global_id = self.tracking_system.matching_cache_manager.get_cached_global_id(camera_id, local_id)
        if cached_global_id is not None:
            return cached_global_id
        
        # 2. ÏÉàÎ°úÏö¥ Í∞ùÏ≤¥: ÏÇ¨Ï†Ñ Îì±Î°ù Îß§Ïπ≠ ÏãúÎèÑ
        print(f"[DEBUG] üÜï ÏÉàÎ°úÏö¥ Í∞ùÏ≤¥ ÌÉêÏßÄ: Camera {camera_id}, Local ID {local_id}")
        
        try:
            # Ïù¥ÎØ∏ÏßÄ ÌÅ¨Î°≠
            crop_img = self.tracking_system.image_processor.crop_bbox_from_frame(frame, bbox)
            if crop_img.size == 0:
                print(f"[DEBUG] Ïù¥ÎØ∏ÏßÄ ÌÅ¨Î°≠ Ïã§Ìå® - Local ID {local_id}Î•º Global IDÎ°ú ÏÇ¨Ïö©")
                self.tracking_system.matching_cache_manager.add_matching_cache(camera_id, local_id, local_id)
                return local_id
            
            # Feature Ï∂îÏ∂ú
            feature = self.tracking_system.image_processor.extract_feature(crop_img)
            if feature is None:
                print(f"[DEBUG] Feature Ï∂îÏ∂ú Ïã§Ìå® - Local ID {local_id}Î•º Global IDÎ°ú ÏÇ¨Ïö©")
                self.tracking_system.matching_cache_manager.add_matching_cache(camera_id, local_id, local_id)
                return local_id
            
            # Pre-Registration Matcher ÏÇ¨Ïö©
            pre_reg_match = self.tracking_system.reid.pre_reg_matcher.match(feature)
            
            if pre_reg_match:
                # Îß§Ïπ≠ ÏÑ±Í≥µ: ÏÇ¨Ï†Ñ Îì±Î°ùÎêú Global ID ÏÇ¨Ïö©
                print(f"[DEBUG] ‚úÖ Pre-Registration Îß§Ïπ≠ ÏÑ±Í≥µ: Local {local_id} -> Global {pre_reg_match}")
                self.tracking_system.matching_cache_manager.add_matching_cache(camera_id, local_id, pre_reg_match)
                return pre_reg_match
            else:
                # Îß§Ïπ≠ Ïã§Ìå®: Local IDÎ•º Global IDÎ°ú ÏÇ¨Ïö©
                print(f"[DEBUG] ‚ùå Pre-Registration Îß§Ïπ≠ Ïã§Ìå®: Local ID {local_id}Î•º Global IDÎ°ú ÏÇ¨Ïö©")
                self.tracking_system.matching_cache_manager.add_matching_cache(camera_id, local_id, local_id)
                return local_id
                
        except Exception as e:
            print(f"[DEBUG] ‚ùå Pre-Registration Îß§Ïπ≠ Ï§ë Ïò§Î•ò: {e} - Local ID {local_id}Î•º Global IDÎ°ú ÏÇ¨Ïö©")
            self.tracking_system.matching_cache_manager.add_matching_cache(camera_id, local_id, local_id)
            return local_id
    
    def add_gui_info(self, frame, camera_id, frame_id, detection_count, fps, violations):
        """GUIÏóê Ï†ïÎ≥¥ Ï∂îÍ∞Ä (ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©)"""
        # Î∞∞Í≤Ω Ï†ïÎ≥¥ Ìå®ÎÑê
        cv2.rectangle(frame, (10, 10), (400, 120), (0, 0, 0), -1)
        cv2.rectangle(frame, (10, 10), (400, 120), (255, 255, 255), 2)
        
        # Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏ (ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©)
        info_lines = [
            f"Camera: {camera_id}",
            f"Frame: {frame_id}",
            f"Tracks: {detection_count}",
            f"FPS: {fps:.1f}",
            f"Mode: ByteTrack + Pre-Reg"  # ByteTrack + Pre-RegistrationÎßå ÏÇ¨Ïö© ÌëúÏãú
        ]
        
        for i, line in enumerate(info_lines):
            y_pos = 35 + i * 18
            cv2.putText(frame, line, (20, y_pos), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        # ByteTrack + Pre-Registration Î™®Îìú ÌëúÏãú
        cv2.rectangle(frame, (10, 130), (400, 160), (0, 255, 255), -1)
        cv2.putText(frame, f"BYTETRACK + PRE-REGISTRATION", (20, 150), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
    
    def run_multi_video_gui(self):
        """Î©ÄÌã∞ ÎπÑÎîîÏò§ GUI Ïã§Ìñâ"""
        print("üöÄ Starting Multi-Video GUI Processing (ByteTrack + Pre-Registration)...")
        print(f"üìπ Processing {len(self.video_paths)} videos")
        
        # Í∞Å ÎπÑÎîîÏò§Î≥Ñ Ïä§Î†àÎìú ÏÉùÏÑ±
        threads = []
        for i, video_path in enumerate(self.video_paths):
            thread = threading.Thread(
                target=self.process_video_thread,
                args=(video_path, i),
                daemon=True
            )
            threads.append(thread)
            thread.start()
        
        try:
            # Î©îÏù∏ Î£®ÌîÑ (ÌÇ§ ÏûÖÎ†• Ï≤òÎ¶¨)
            while not self.stop_event.is_set():
                # ÌÇ§ ÏûÖÎ†• ÌôïÏù∏
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    print("üõë Quit requested by user")
                    break
                
                # Î™®Îì† ÏúàÎèÑÏö∞Í∞Ä Îã´ÌòîÎäîÏßÄ ÌôïÏù∏ (ÏïàÏ†ÑÌïòÍ≤å)
                try:
                    if self.window_names and cv2.getWindowProperty(self.window_names[0], cv2.WND_PROP_VISIBLE) < 1:
                        print("üõë Window closed by user")
                        break
                except:
                    pass  # ÏúàÎèÑÏö∞Í∞Ä ÏïÑÏßÅ ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏùå
                
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Interrupted by user")
        finally:
            # Ï†ïÎ¶¨
            self.stop_event.set()
            for thread in threads:
                thread.join(timeout=1.0)
            
            cv2.destroyAllWindows()
            print("‚úÖ GUI processing completed (ByteTrack + Pre-Registration)")


def main():
    """GUI Î≤ÑÏ†Ñ Î©îÏù∏ Ìï®Ïàò (ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©)"""
    parser = argparse.ArgumentParser(
        description="ByteTrack + Pre-Registration Matcher Only Tracking System with GUI (Ultralytics)"
    )
    parser.add_argument(
        '--videos',
        nargs='+',
        type=str,
        default=settings.VIDEO_INPUT_PATHS,
        help='List of video file paths.'
    )
    parser.add_argument(
        '--yolo_model',
        type=str,
        default=settings.YOLO_MODEL_PATH,
        help='Path to the YOLOv8 model file for person detection.'
    )
    parser.add_argument(
        '--ppe_model',
        type=str,
        default=settings.PPE_MODEL_PATH,
        help='Path to the PPE detection model file.'
    )
    parser.add_argument(
        '--calibration_files',
        nargs='+',
        type=str,
        help='List of calibration files for each camera (in order).'
    )
    parser.add_argument(
        '--redis_host',
        type=str,
        default="localhost",
        help='Redis server host.'
    )
    parser.add_argument(
        '--redis_port',
        type=int,
        default=6379,
        help='Redis server port.'
    )
    args = parser.parse_args()
    
    # Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÌååÏùº Îß§Ìïë
    calibration_files = {}
    if args.calibration_files:
        for i, calib_file in enumerate(args.calibration_files):
            calibration_files[i] = calib_file
    else:
        print("No calibration files specified. Using homography matrices from settings.py")
    
    # ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî (ByteTrack + Pre-Registration MatcherÎßå ÏÇ¨Ïö©)
    tracker_config = settings.TRACKER_CONFIG
    reid_config = settings.REID_CONFIG  # ÏÑ§Ï†ïÏùÄ Î°úÎìúÌïòÏßÄÎßå ÏùºÎ∂ÄÎßå ÏÇ¨Ïö©
    
    redis_conf = {
        "host": args.redis_host,
        "port": args.redis_port,
        "camera_id": "camera_0"
    }
    
    # Ultralytics Í∏∞Î∞ò ÌÜµÌï© Ï∂îÏ†Å ÏãúÏä§ÌÖú ÏÉùÏÑ±
    tracking_system = IntegratedTrackingSystemUltra(
        video_paths=args.videos,
        model_path=args.yolo_model,
        tracker_config=tracker_config,
        redis_conf=redis_conf,
        reid_conf=reid_config,
        calibration_files=calibration_files,
        backend_url=None,  # Î∞±ÏóîÎìú Ï†ÑÏÜ° ÎπÑÌôúÏÑ±Ìôî
        ppe_model_path=args.ppe_model
    )
    
    print(f"‚ñ∂ Processing {len(args.videos)} videos with GUI display (ByteTrack + Pre-Registration)")
    print(f"‚ö†Ô∏è  Only ByteTrack + Pre-Registration Matcher will be used")
    for i, video_path in enumerate(args.videos):
        print(f"  Camera {i}: {video_path}")
        if i in calibration_files:
            print(f"    Calibration: {calibration_files[i]}")
        else:
            print(f"    Homography: Loaded from settings.py")
    
    # GUI ÎπÑÎîîÏò§ ÌîÑÎ°úÏÑ∏ÏÑú ÏÉùÏÑ± Î∞è Ïã§Ìñâ
    gui_processor = GUIVideoProcessor(tracking_system)
    gui_processor.run_multi_video_gui()
    
    print("üéâ GUI processing completed (ByteTrack + Pre-Registration)!")


if __name__ == '__main__':
    main()
